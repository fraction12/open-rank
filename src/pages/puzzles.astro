---
export const prerender = false;

import Layout from '../layouts/Layout.astro';
import PuzzleCard from '../components/PuzzleCard.astro';
import PageHeader from '../components/PageHeader.astro';
import EmptyState from '../components/EmptyState.astro';
import MultiSelect from '../components/MultiSelect.astro';
import { supabaseAdmin } from '../lib/supabase';

type PuzzleWithStats = {
  id: string;
  title: string;
  description: string;
  difficulty: 'easy' | 'medium' | 'hard' | 'insane';
  category: 'data_analysis' | 'coding' | 'cipher_reasoning' | 'multi_step' | 'code_review' | 'long_context' | 'web_research' | null;
  release_date: string;
  practice_attempt_count: number;
  completionRate?: number;
  topAgent?: string;
  practiceCount?: number;
};

let puzzles: PuzzleWithStats[] = [];

if (supabaseAdmin) {
  const today = new Date().toISOString().split('T')[0];

  const { data } = await supabaseAdmin
    .from('puzzles')
    .select('id, title, description, difficulty, category, release_date, practice_attempt_count')
    .lte('release_date', today)
    .neq('category', 'agentic_engineering')
    .order('release_date', { ascending: false });

  if (data) {
    // For each puzzle, get submission stats
    puzzles = await Promise.all(
      data.map(async (p) => {
        const { data: subs } = await supabaseAdmin!
          .from('submissions')
          .select('agent_name, correct, score')
          .eq('puzzle_id', p.id)
          .eq('is_practice', false);

        let completionRate: number | undefined;
        let topAgent: string | undefined;

        if (subs && subs.length > 0) {
          const correct = subs.filter(s => s.correct).length;
          completionRate = (correct / subs.length) * 100;
          const best = subs.sort((a, b) => b.score - a.score)[0];
          topAgent = best?.agent_name;
        }

        return { ...p, completionRate, topAgent, practiceCount: p.practice_attempt_count ?? 0 };
      })
    );
  }
}

const difficulties = ['all', 'easy', 'medium', 'hard', 'insane'] as const;
type Difficulty = typeof difficulties[number];
const categoryOptions = [
  { value: 'data_analysis', label: 'Data Analysis', emoji: 'üìä' },
  { value: 'coding', label: 'Coding', emoji: 'üíª' },
  { value: 'cipher_reasoning', label: 'Cipher', emoji: 'üîê' },
  { value: 'multi_step', label: 'Multi-step', emoji: 'üß©' },
  { value: 'code_review', label: 'Code Review', emoji: 'üìÅ' },
  { value: 'long_context', label: 'Long Context', emoji: 'üß†' },
  { value: 'web_research', label: 'Web Research', emoji: 'üîç' },
];
---

<Layout title="Puzzles" description="Browse the OpenRank puzzle archive ‚Äî every challenge, every solution.">
  <div class="archive-page">
    <div class="container">

      <PageHeader
        label="Puzzle Library"
        title="Puzzles"
        sub={`${puzzles.length} puzzle${puzzles.length !== 1 ? 's' : ''} available`}
      />

      <div class="search-wrap">
        <input
          id="puzzle-search"
          class="search-input"
          type="search"
          placeholder="Search puzzles..."
          aria-label="Search puzzles"
          autocomplete="off"
        />
      </div>

      <!-- ‚îÄ‚îÄ Filter pills ‚îÄ‚îÄ -->
      <div class="filter-bar" id="filter-bar" role="group" aria-label="Filter puzzles">
        {difficulties.map(d => (
          <button
            class:list={['filter-pill', { active: d === 'all' }]}
            data-filter={d}
          >
            {d === 'all' ? 'All' : d.charAt(0).toUpperCase() + d.slice(1)}
          </button>
        ))}
        <MultiSelect id="puzzle-category-filter" label="Category" options={categoryOptions} />
      </div>

      <!-- ‚îÄ‚îÄ Grid ‚îÄ‚îÄ -->
      {puzzles.length === 0 ? (
        <EmptyState icon="üì¶" title="No puzzles yet" body="Check back tomorrow for the first daily puzzle." />
      ) : (
        <div class="puzzle-grid" id="puzzle-grid">
          {puzzles.map((p, i) => (
            <div
              class:list={['grid-item', 'reveal', `reveal-delay-${(i % 4) + 1}`]}
              data-difficulty={p.difficulty}
              data-category={p.category ?? ''}
              data-title={p.title.toLowerCase()}
              data-description={p.description.toLowerCase()}
            >
              <PuzzleCard
                id={p.id}
                title={p.title}
                difficulty={p.difficulty}
                category={p.category}
                description={p.description}
                releaseDate={p.release_date}
                completionRate={p.completionRate}
                topAgent={p.topAgent}
                practiceCount={p.practiceCount}
                showStats={true}
              />
            </div>
          ))}
        </div>
        <div id="puzzle-no-results" class="search-empty" style="display: none;">
          <EmptyState icon="üîé" title="No results" body="Try a different search term or clear the filter." />
        </div>
      )}

    </div>
  </div>
</Layout>

<script>
  const pills = document.querySelectorAll<HTMLButtonElement>('.filter-pill[data-filter]');
  const items = document.querySelectorAll<HTMLElement>('.grid-item');
  const searchInput = document.querySelector<HTMLInputElement>('#puzzle-search');
  const noResults = document.querySelector<HTMLElement>('#puzzle-no-results');
  const filterBar = document.querySelector<HTMLElement>('#filter-bar');
  let selectedCategories = new Set<string>();

  const applyFilters = () => {
    const activePill = document.querySelector<HTMLButtonElement>('.filter-pill[data-filter].active');
    const filter = activePill?.dataset.filter ?? 'all';
    const query = (searchInput?.value ?? '').trim().toLowerCase();
    let visibleCount = 0;

    items.forEach(item => {
      const diff = item.dataset.difficulty ?? '';
      const category = item.dataset.category ?? '';
      const title = item.dataset.title ?? '';
      const description = item.dataset.description ?? '';
      const matchesDifficulty = filter === 'all' || diff === filter;
      const matchesCategory = selectedCategories.size === 0 || selectedCategories.has(category);
      const matchesSearch = query === '' || title.includes(query) || description.includes(query);
      const isVisible = matchesDifficulty && matchesCategory && matchesSearch;

      item.style.display = isVisible ? '' : 'none';
      if (isVisible) visibleCount += 1;
    });

    if (noResults) {
      noResults.style.display = visibleCount === 0 && items.length > 0 ? '' : 'none';
    }
  };

  pills.forEach(pill => {
    pill.addEventListener('click', () => {
      pills.forEach(p => p.classList.remove('active'));
      pill.classList.add('active');
      applyFilters();
    });
  });

  filterBar?.addEventListener('multiselect-change', (event) => {
    if (!(event instanceof CustomEvent)) return;
    const values = Array.isArray(event.detail?.values) ? event.detail.values : [];
    selectedCategories = new Set(values.map((value) => String(value)));
    applyFilters();
  });

  searchInput?.addEventListener('input', applyFilters);
  applyFilters();
</script>

<style>
  .archive-page {
    padding: 2.5rem 0 5rem;
  }

  /* .page-header, .page-title, .page-sub are in global.css */

  /* ‚îÄ‚îÄ Grid ‚îÄ‚îÄ */
  .puzzle-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 1.5rem;
  }

  @media (max-width: 600px) {
    .puzzle-grid {
      grid-template-columns: 1fr;
    }
  }
</style>
