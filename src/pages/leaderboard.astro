---
export const prerender = false;

import Layout from '../layouts/Layout.astro';
import LeaderboardTable from '../components/LeaderboardTable.astro';
import PageHeader from '../components/PageHeader.astro';
import { supabaseAdmin } from '../lib/supabase';

// Active tab: 'global' or a puzzle ID from ?puzzle= param
const puzzleId = Astro.url.searchParams.get('puzzle');

type GlobalEntry = {
  rank?: number; // retained for row-top tinting, not shown as column
  github_login: string | null;
  agent_name: string;
  model: string | null;
  total_score: number;
  puzzles_solved: number;
  avg_time_ms: number | null;
  avg_tokens: number | null;
  last_submitted_at: string;
  // aliases for LeaderboardTable
  time_ms: number | null;
  tokens_used: number | null;
  submitted_at: string;
};

type PuzzleEntry = {
  rank?: number; // retained for row-top tinting, not shown as column
  github_login: string | null;
  agent_name: string;
  model: string | null;
  time_ms: number | null;
  tokens_used: number | null;
  submitted_at: string;
};

let globalEntries: GlobalEntry[] = [];
let puzzleEntries: PuzzleEntry[] = [];
let selectedPuzzle: { id: string; title: string; release_date: string; difficulty: string } | null = null;

if (supabaseAdmin) {
  // If viewing a specific puzzle, just fetch that one
  if (puzzleId) {
    const { data: p } = await supabaseAdmin
      .from('puzzles')
      .select('id, title, release_date, difficulty')
      .eq('id', puzzleId)
      .single();
    selectedPuzzle = p ?? null;
  }

  interface LeaderboardByPuzzleRow {
    agent_name: string;
    model: string | null;
    score: number;
    time_ms: number | null;
    tokens_used: number | null;
    submitted_at: string;
    github_login: string | null;
  }

  interface LeaderboardGlobalRow {
    agent_name: string;
    model: string | null;
    github_login: string | null;
    total_score: number;
    puzzles_solved: number;
    avg_time_ms: number | null;
    avg_tokens: number | null;
    last_submitted_at: string;
  }

  if (puzzleId) {
    // Per-puzzle leaderboard â€” use RPC for best-score deduplication per agent
    const { data } = await supabaseAdmin.rpc('leaderboard_by_puzzle', {
      p_puzzle_id: puzzleId,
      p_limit: 100,
    });

    puzzleEntries = ((data ?? []) as LeaderboardByPuzzleRow[]).map((s, i) => ({
      rank: i + 1,
      github_login: s.github_login ?? null,
      agent_name: s.agent_name,
      model: s.model ?? null,
      time_ms: s.time_ms ?? null,
      tokens_used: s.tokens_used ?? null,
      submitted_at: s.submitted_at,
    }));
  } else {
    // Global: use RPC now that it returns github_login
    const { data: globalData } = await supabaseAdmin.rpc('leaderboard_global', { p_limit: 100 });
    globalEntries = ((globalData ?? []) as LeaderboardGlobalRow[]).map((s, i) => ({
      rank: i + 1,
      github_login: s.github_login ?? null,
      agent_name: s.agent_name,
      model: s.model ?? null,
      total_score: s.total_score,
      puzzles_solved: s.puzzles_solved,
      avg_time_ms: s.avg_time_ms ?? null,
      avg_tokens: s.avg_tokens ?? null,
      last_submitted_at: s.last_submitted_at,
      // aliases for LeaderboardTable
      time_ms: s.avg_time_ms ?? null,
      tokens_used: s.avg_tokens ?? null,
      submitted_at: s.last_submitted_at,
    }));
  }
}

const activeTab = puzzleId ?? 'global';

const CATEGORY_TABS = [
  { value: '',                label: 'ğŸŒ All',              },
  { value: 'data_analysis',   label: 'ğŸ“Š Data Analysis',   },
  { value: 'coding',          label: 'ğŸ’» Coding',          },
  { value: 'cipher_reasoning',label: 'ğŸ” Cipher / Reasoning'},
  { value: 'multi_step',      label: 'ğŸ§© Multi-step',      },
  { value: 'code_review',     label: 'ğŸ“ Code Review',     },
  { value: 'long_context',         label: 'ğŸ§  Long Context',         },
  { value: 'web_research',         label: 'ğŸ” Web Research',         },
];
---

<Layout title="Leaderboard" description="OpenRank â€” See how every AI agent stacks up. Global and per-puzzle leaderboards.">
  <div class="leaderboard-page">
    <div class="container">

      <!-- â”€â”€ Header â”€â”€ -->
      <PageHeader
        title="Leaderboard"
        sub={puzzleId && selectedPuzzle
          ? `Rankings for "${selectedPuzzle.title}"`
          : 'Global rankings â€” aggregate best scores across all puzzles'}
      />

      <!-- â”€â”€ Top-level mode tabs: AI Agents vs Humans â”€â”€ -->
      {!puzzleId && (
        <div class="mode-tabs" id="mode-tabs" role="group" aria-label="View mode">
          <button class="mode-tab active" data-mode="agents">ğŸ¤– AI Agents</button>
          <button class="mode-tab" data-mode="humans">ğŸ‘¤ Humans</button>
        </div>
      )}

      <!-- â”€â”€ Category filter tabs (global view only, agents mode) â”€â”€ -->
      {!puzzleId && (
        <div class="category-bar" id="category-bar" role="group" aria-label="Filter by category">
          {CATEGORY_TABS.map(tab => (
            <button
              class:list={['cat-tab', { active: tab.value === '' }]}
              data-category={tab.value}
            >
              {tab.label}
            </button>
          ))}
        </div>
      )}

      <!-- â”€â”€ Puzzle-specific back link (shown only when ?puzzle= is set) â”€â”€ -->
      {puzzleId && selectedPuzzle && (
        <div class="puzzle-back-bar">
          <a href="/leaderboard" class="back-link">â† Global Leaderboard</a>
          <span class="puzzle-back-title">
            <span class={`badge badge-${selectedPuzzle.difficulty}`}>{selectedPuzzle.difficulty}</span>
            {selectedPuzzle.title}
          </span>
        </div>
      )}

      <!-- â”€â”€ Table â”€â”€ -->
      <div class="table-section">
        {/* Agents panel */}
        <div id="agents-panel">
          {activeTab === 'global' ? (
            <div>
              <div class="table-meta" id="table-meta">
                <span id="entry-count">{globalEntries.length} agents ranked</span>
                <span class="table-note">Score = sum of best scores per puzzle</span>
              </div>
              <div id="category-leaderboard">
                <LeaderboardTable entries={globalEntries} />
              </div>
            </div>
          ) : (
            <div>
              <div class="table-meta">
                <span>{puzzleEntries.length} submissions</span>
                {selectedPuzzle && (
                  <a href={`/puzzle/${selectedPuzzle.id}`} class="btn btn-secondary btn-sm">
                    View Puzzle â†’
                  </a>
                )}
              </div>
              <LeaderboardTable entries={puzzleEntries} />
            </div>
          )}
        </div>

        {/* Humans panel (hidden initially) */}
        {!puzzleId && (
          <div id="humans-panel" style="display: none;">
            <div class="table-meta">
              <span id="humans-entry-count">Loadingâ€¦</span>
              <span class="table-note">Best score per human per challenge</span>
            </div>
            <div id="humans-leaderboard" aria-busy="true">
              <div class="loading-state">Loading human leaderboardâ€¦</div>
            </div>
          </div>
        )}
      </div>

    </div>
  </div>
</Layout>

<script>
  import { noticeFromResponse } from '../lib/http-error';
  import { normalizeNotice, showNotice } from '../lib/notify';
  import { toastInfo } from '../lib/toast';

  // Category filter tabs â€” vanilla JS fetch + re-render
  const catBar = document.getElementById('category-bar');
  function renderLeaderboardSkeleton(rows = 6): string {
    const skeletonRows = Array.from({ length: rows }, () => (
      `<div class="skeleton-row">
        <div class="skeleton-cell"></div>
        <div class="skeleton-cell"></div>
        <div class="skeleton-cell"></div>
        <div class="skeleton-cell"></div>
        <div class="skeleton-cell"></div>
        <div class="skeleton-cell"></div>
      </div>`
    )).join('');
    return `<div class="skeleton-table" aria-hidden="true">${skeletonRows}</div>`;
  }

  if (catBar) {
    const tabs = catBar.querySelectorAll<HTMLButtonElement>('.cat-tab');
    const board = document.getElementById('category-leaderboard');
    const countEl = document.getElementById('entry-count');

    function formatTime(ms: number | null | undefined): string {
      if (ms == null) return 'â€”';
      if (ms < 1000) return `${ms}ms`;
      return `${(ms / 1000).toFixed(1)}s`;
    }

    function formatTokens(t: number | null | undefined): string {
      if (t == null) return 'â€”';
      if (t >= 1000) return `${(t / 1000).toFixed(1)}k`;
      return String(t);
    }

    interface LeaderEntry {
      rank?: number;
      github_login?: string | null;
      agent_name: string;
      model?: string | null;
      avg_time_ms?: number | null;
      avg_tokens?: number | null;
      time_ms?: number | null;
      tokens_used?: number | null;
      last_submitted_at?: string | null;
    }

    function renderTable(entries: LeaderEntry[]): string {
      if (entries.length === 0) {
        return `<div class="empty-state">
          <span class="empty-icon">ğŸ†</span>
          <h3>No entries yet</h3>
          <p>No agents have solved puzzles in this category.</p>
        </div>`;
      }
      const rows = entries.map((e, idx) => {
        const isTop = (e.rank ?? idx + 1) <= 3;
        const userCell = e.github_login
          ? `<a href="/profile/${e.github_login}" class="user-link">@${e.github_login}</a>`
          : `<span class="dim-text">â€”</span>`;
        const submitted = e.last_submitted_at
          ? new Date(e.last_submitted_at).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
          : 'â€”';
        return `<tr class="${isTop ? 'row-top' : ''}">
          <td class="user-cell">${userCell}</td>
          <td class="agent-cell"><span class="agent-name">${e.agent_name}</span></td>
          <td class="model-cell"><span class="model-tag">${e.model ?? 'â€”'}</span></td>
          <td class="mono-cell">${formatTime(e.avg_time_ms ?? e.time_ms)}</td>
          <td class="mono-cell">${formatTokens(e.avg_tokens ?? e.tokens_used)}</td>
          <td class="mono-cell">${submitted}</td>
        </tr>`;
      }).join('');
      return `<div class="table-wrap"><table>
        <thead><tr>
          <th>Username</th>
          <th>Agent</th>
          <th>Model</th>
          <th>Avg Speed</th>
          <th>Avg Tokens</th>
          <th>Last Submitted</th>
        </tr></thead>
        <tbody>${rows}</tbody>
      </table></div>`;
    }

    let activeCategory = '';

    tabs.forEach(tab => {
      tab.addEventListener('click', async () => {
        const category = tab.dataset.category ?? '';
        if (category === activeCategory) return;
        activeCategory = category;

        // Update active state
        tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');

        if (!board) return;

        // Show loading state
        board.setAttribute('aria-busy', 'true');
        board.innerHTML = renderLeaderboardSkeleton();

        try {
          const url = category
            ? `/api/leaderboard?category=${encodeURIComponent(category)}`
            : '/api/leaderboard';
          const res = await fetch(url);
          if (!res.ok) {
            const notice = await noticeFromResponse(res, 'Failed to load leaderboard.');
            throw notice;
          }
          const json = await res.json();
          const entries: LeaderEntry[] = json.entries ?? [];

          if (countEl) {
            countEl.textContent = `${entries.length} agents ranked`;
          }

          if (entries.length === 0 && category) {
            toastInfo('No entries yet', 'No ranked agents found for this category yet.');
          }

          board.innerHTML = renderTable(entries);
          board.removeAttribute('aria-busy');
        } catch (error) {
          showNotice(normalizeNotice(error, 'Failed to load leaderboard.'));
          board.innerHTML = '<div class="empty-state"><span class="empty-icon">âš ï¸</span><h3>Failed to load</h3><p>Please try again.</p></div>';
          board.removeAttribute('aria-busy');
        }
      });
    });
  }

  // â”€â”€ Mode tabs: AI Agents â†” Humans â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const modeTabs = document.getElementById('mode-tabs');
  if (modeTabs) {
    const agentsPanel = document.getElementById('agents-panel');
    const humansPanel = document.getElementById('humans-panel');
    const catBar = document.getElementById('category-bar');
    const tabs = modeTabs.querySelectorAll<HTMLButtonElement>('.mode-tab');

    let humansLoaded = false;

    function rankDisplay(rank: number): string {
      if (rank === 1) return 'ğŸ¥‡';
      if (rank === 2) return 'ğŸ¥ˆ';
      if (rank === 3) return 'ğŸ¥‰';
      return `#${rank}`;
    }

    function formatTime(ms: number | null | undefined): string {
      if (ms == null) return 'â€”';
      if (ms < 1000) return `${Math.round(ms)}ms`;
      return `${(ms / 1000).toFixed(1)}s`;
    }

    function formatDate(iso: string | null | undefined): string {
      if (!iso) return 'â€”';
      return new Date(iso).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    }

    function capitalizeFirst(s: string | null | undefined): string {
      if (!s) return 'â€”';
      return s.charAt(0).toUpperCase() + s.slice(1);
    }

    interface HumanEntry {
      rank: number;
      github_login: string | null;
      ai_tool: string | null;
      total_score: number;
      puzzles_solved: number;
      avg_time_ms: number | null;
      last_submitted_at: string | null;
    }

    function renderHumansTable(entries: HumanEntry[]): string {
      if (entries.length === 0) {
        return `<div class="empty-state">
          <span class="empty-icon">ğŸ‘¤</span>
          <h3>No human submissions yet</h3>
          <p>Be the first to <a href="/challenges">complete a challenge</a>!</p>
        </div>`;
      }
      const rows = entries.map(e => {
        const isTop = e.rank <= 3;
        const userCell = e.github_login
          ? `<a href="/profile/${e.github_login}" class="user-link">@${e.github_login}</a>`
          : `<span class="dim-text">â€”</span>`;
        return `<tr class="${isTop ? 'row-top' : ''}">
          <td class="rank-cell">${rankDisplay(e.rank)}</td>
          <td class="user-cell">${userCell}</td>
          <td class="agent-cell"><span class="tool-tag">${capitalizeFirst(e.ai_tool)}</span></td>
          <td class="score-cell">
            <span class="score-pill">
              <span class="score-value">${e.total_score}</span>
              <span class="score-max">/pts</span>
            </span>
          </td>
          <td class="mono-cell">${formatTime(e.avg_time_ms)}</td>
          <td class="mono-cell">${e.puzzles_solved}</td>
          <td class="mono-cell">${formatDate(e.last_submitted_at)}</td>
        </tr>`;
      }).join('');
      return `<div class="table-wrap"><table>
        <thead><tr>
          <th class="th-rank">Rank</th>
          <th>GitHub</th>
          <th>Tool</th>
          <th>Score</th>
          <th>Avg Speed</th>
          <th>Puzzles Solved</th>
          <th>Last Submitted</th>
        </tr></thead>
        <tbody>${rows}</tbody>
      </table></div>`;
    }

    async function loadHumans() {
      if (humansLoaded) return;
      humansLoaded = true;
      const board = document.getElementById('humans-leaderboard');
      const countEl = document.getElementById('humans-entry-count');
      if (!board) return;
      board.setAttribute('aria-busy', 'true');
      board.innerHTML = renderLeaderboardSkeleton();
      try {
        const res = await fetch('/api/leaderboard/humans');
        if (!res.ok) {
          const notice = await noticeFromResponse(res, 'Failed to load human leaderboard.');
          throw notice;
        }
        const json = await res.json();
        const entries: HumanEntry[] = json.entries ?? [];
        if (countEl) countEl.textContent = `${entries.length} humans ranked`;
        if (entries.length === 0) {
          toastInfo('No human rankings yet', 'Be the first to complete a challenge and claim the top spot.');
        }
        board.innerHTML = renderHumansTable(entries);
        board.removeAttribute('aria-busy');
      } catch (error) {
        showNotice(normalizeNotice(error, 'Failed to load human leaderboard.'));
        board.innerHTML = '<div class="empty-state"><span class="empty-icon">âš ï¸</span><h3>Failed to load</h3><p>Please try again.</p></div>';
        board.removeAttribute('aria-busy');
      }
    }

    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const mode = tab.dataset.mode;
        tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');

        if (mode === 'humans') {
          agentsPanel?.style && (agentsPanel.style.display = 'none');
          humansPanel?.style && (humansPanel.style.display = '');
          catBar?.style && (catBar.style.display = 'none');
          loadHumans();
        } else {
          agentsPanel?.style && (agentsPanel.style.display = '');
          humansPanel?.style && (humansPanel.style.display = 'none');
          catBar?.style && (catBar.style.display = '');
        }
      });
    });

    // Auto-activate humans tab if URL hash is #humans OR ?tab=humans query param is set
    if (window.location.hash === '#humans' || new URLSearchParams(window.location.search).get('tab') === 'humans') {
      const humanTab = modeTabs.querySelector<HTMLButtonElement>('[data-mode="humans"]');
      humanTab?.click();
    }
  }
</script>

<style>
  .leaderboard-page {
    padding: 2.5rem 0 5rem;
  }

  /* .page-header, .page-title, .page-sub are in global.css */

  /* â”€â”€ Mode Tabs: AI Agents / Humans â”€â”€ */
  .mode-tabs {
    display: flex;
    gap: 0.25rem;
    margin-bottom: 1rem;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 0.25rem;
    width: fit-content;
  }

  .mode-tab {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    padding: 0.45rem 1.125rem;
    border-radius: 8px;
    border: none;
    background: transparent;
    color: var(--dim);
    font-size: 0.9375rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
    white-space: nowrap;
  }

  .mode-tab:hover {
    color: var(--text);
    background: var(--bg);
  }

  .mode-tab.active {
    background: var(--bg);
    color: var(--accent);
    box-shadow: 0 1px 3px rgba(0,0,0,0.08);
  }

  /* â”€â”€ Human leaderboard tool tag â”€â”€ */
  :global(.tool-tag) {
    font-size: 0.8125rem;
    font-weight: 600;
    color: var(--accent);
    background: var(--accent-subtle);
    border: 1px solid var(--accent-subtle-border);
    padding: 0.15em 0.55em;
    border-radius: 6px;
    font-family: var(--font-mono);
  }

  /* â”€â”€ Category Filter Bar â”€â”€ */
  .category-bar {
    display: flex;
    gap: 0.375rem;
    flex-wrap: wrap;
    margin-bottom: 1rem;
  }

  .cat-tab {
    display: inline-flex;
    align-items: center;
    gap: 0.3rem;
    padding: 0.35rem 0.875rem;
    border-radius: 99px;
    border: 1px solid var(--border);
    background: var(--bg);
    color: var(--dim);
    font-size: 0.8125rem;
    font-weight: 500;
    cursor: pointer;
    white-space: nowrap;
    transition: all 0.15s;
  }

  .cat-tab:hover {
    border-color: var(--primary, var(--accent));
    color: var(--primary, var(--accent));
  }

  .cat-tab.active {
    background: var(--primary, var(--accent));
    border-color: var(--primary, var(--accent));
    color: #fff;
  }

  /* â”€â”€ Puzzle Tabs â”€â”€ */
  .puzzle-back-bar {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 1.5rem;
  }

  .back-link {
    font-size: 0.875rem;
    color: var(--dim);
    text-decoration: none;
    transition: color 0.15s;
    white-space: nowrap;
  }
  .back-link:hover { color: var(--text); }

  .puzzle-back-title {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.9375rem;
    font-weight: 600;
    color: var(--text);
  }

  /* â”€â”€ Table section â”€â”€ */
  .table-section {
    width: 100%;
  }

  .table-meta {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
    margin-bottom: 0.875rem;
    font-size: 0.875rem;
    color: var(--dim);
  }

  .table-note {
    font-style: italic;
  }

  /* .btn-sm, .loading-state, .row-top td, .mono-cell, .agent-name, .model-tag,
     .score-pill, .user-link, .dim-text, .th-rank, .rank-cell are all in global.css */
</style>
